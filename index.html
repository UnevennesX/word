<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Pro v11 - División de Página Animada</title> <!-- Title Updated -->
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        /* CSS */
         :root{--bg-dark-L1:#1e1e1e;--bg-dark-L2:#2a2a2a;--bg-dark-L3:#3f3f3f;--text-color-primary:#cccccc;--text-color-secondary:#999999;--border-color:#4a4a4a;--accent-color:#4e8cff;--button-hover-bg:#454545;--button-selected-bg:#555555;--button-selected-border:#777777;--error-color:#ff6b6b;--success-color:#6bff8d;--font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';}
        *{margin:0;padding:0;box-sizing:border-box;}
        body{font-family:var(--font-family);background-color:var(--bg-dark-L1);color:var(--text-color-primary);font-size:13px;overflow:hidden;height:100vh;display:flex;flex-direction:column;}
        .app-container{display:flex;flex-direction:column;height:100%;}
        .ribbon-bar{ background-color:var(--bg-dark-L2); padding:8px 15px; border-bottom:1px solid var(--border-color); display:flex; gap:12px; align-items:center; box-shadow:0 2px 4px rgba(0,0,0,0.2); justify-content: space-between; flex-shrink: 0; }
        .ribbon-left-center-groups { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
        .ribbon-right-menu { display: flex; align-items: center; gap: 12px; margin-left: auto; }
        .ribbon-group{display:flex;align-items:center;gap:3px;}
        .ribbon-separator{width:1px;height:24px;background-color:var(--border-color);margin:0 10px;}
        .icon-button{background-color:transparent;border:1px solid transparent;color:var(--text-color-primary);padding:5px;border-radius:4px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;min-width:30px;height:30px;font-size:15px;transition:background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease;position:relative;}
        .icon-button[title]:hover::after{content:attr(title);position:absolute;top:110%;left:50%;transform:translateX(-50%);background-color:rgba(40,40,40,0.9);color:var(--text-color-primary);padding:4px 8px;border-radius:3px;font-size:11px;white-space:nowrap;z-index:10;pointer-events:none;opacity:0;transition:opacity 0.2s ease 0.1s;}
        .icon-button[title]:hover:hover::after{opacity:1;}
        .icon-button:hover:not(:disabled){background-color:var(--button-hover-bg);border-color:var(--border-color);}
        .icon-button.selected:not(:disabled){background-color:var(--button-selected-bg);border-color:var(--button-selected-border); color: var(--accent-color);}
        .icon-button:disabled{opacity:0.4;cursor:not-allowed;}
        .icon-button:disabled:hover{background-color:transparent;border-color:transparent;}
        .font-select, .font-size-select{background-color:var(--bg-dark-L3);border:1px solid var(--border-color);color:var(--text-color-primary);padding:5px 8px;border-radius:4px;font-size:13px;height:30px;cursor:pointer;transition:border-color 0.15s ease;}
        .font-select:hover, .font-size-select:hover{border-color:var(--button-selected-border);}
        .font-select{width:150px;}
        .font-size-select{width:70px;}
        .main-content{ flex-grow:1; padding:25px; background-color:var(--bg-dark-L1); overflow: auto; display: flex; flex-direction: column; align-items: center; gap: 25px; }
        .page-container{ background-color:var(--bg-dark-L3); width:8.5in; max-width:calc(100% - 40px); min-height:11in; height: 11in; padding:1in; box-shadow:0 2px 15px rgba(0,0,0,0.4); border-radius:2px; transform-origin: top center; flex-shrink: 0; position: relative; transition: transform 0.1s ease-out, opacity 0.3s ease-out; /* Added opacity transition */ }
        /* --- Animation Class --- */
        .page-container.new-page-entering {
            opacity: 0;
            transform: translateY(15px) scale(1); /* Start slightly down and faded out */
        }
        .document-area{ width:100%; min-height:calc(11in - 2in); height: calc(11in - 2in); overflow-y: hidden; background-color:transparent; border:none; outline:none; color:var(--text-color-primary); font-family:'Arial', var(--font-family); font-size:12pt; line-height:1.6; resize:none; padding:0; display:block; text-align:inherit; caret-color:var(--accent-color); white-space:pre-wrap; word-wrap: break-word; }
        .document-area::selection{background-color:var(--accent-color);color:var(--bg-dark-L1);}
        .status-bar{background-color:var(--bg-dark-L2);padding:5px 15px;display:flex;justify-content:space-between;align-items:center;border-top:1px solid var(--border-color);height:30px;font-size:11px;color:var(--text-color-secondary);flex-shrink:0;flex-wrap:wrap;gap:15px;}
        .status-left, .status-right{display:flex;align-items:center;gap:15px;}
        .status-right{margin-left:auto;}
        .status-bar .icon-button{height:24px;min-width:24px;font-size:14px;}
        .zoom-slider{width:100px;display:flex;align-items:center;}
        .zoom-slider .slider{width:100%;height:4px;cursor:pointer;appearance:none;background:var(--border-color);border-radius:2px;outline:none;transition:background 0.15s ease;}
        .zoom-slider .slider:hover{background:var(--text-color-secondary);}
        .zoom-slider .slider::-webkit-slider-thumb{appearance:none;width:14px;height:14px;background:var(--text-color-primary);border-radius:50%;cursor:pointer;border:1px solid var(--border-color);}
        .zoom-slider .slider::-moz-range-thumb{width:14px;height:14px;background:var(--text-color-primary);border-radius:50%;cursor:pointer;border:1px solid var(--border-color);}
        .zoom-percentage{min-width:45px;text-align:center;font-weight:500;}
        .ribbon-bar .action-button{background-color:var(--accent-color); border:1px solid transparent; color:var(--bg-dark-L1); padding:4px 12px; border-radius:4px; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:12px; font-weight: 500; height:30px; transition:background-color 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;}
        .ribbon-bar .action-button:hover{background-color:#6aa1ff; border-color:transparent; opacity: 0.9;}
        .status-bar .action-button{background-color:var(--bg-dark-L3);border:1px solid var(--border-color);color:var(--text-color-primary);padding:4px 10px;border-radius:4px;cursor:pointer;display:flex;align-items:center;gap:6px;font-size:11px;height:24px;transition:background-color 0.15s ease, border-color 0.15s ease;}
        .status-bar .action-button:hover{background-color:var(--button-hover-bg);border-color:var(--button-selected-border);}
        .action-button i{font-size:12px;}
        .status-message{padding:0 5px;border-radius:3px;transition:opacity 0.3s ease;}
        .status-message.success{color:var(--success-color);}
        .status-message.error{color:var(--error-color);}
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Ribbon Bar HTML (Unchanged) -->
        <div class="ribbon-bar">
             <div class="ribbon-left-center-groups">
                <div class="ribbon-group"> <button class="icon-button" id="undo-button" title="Deshacer (Ctrl+Z)" disabled><i class="fas fa-undo"></i></button> <button class="icon-button" id="redo-button" title="Rehacer (Ctrl+Y)" disabled><i class="fas fa-redo"></i></button> </div>
                <div class="ribbon-separator"></div>
                <div class="ribbon-group font-controls"> <select class="font-select" id="font-family-select" title="Fuente"> <option style="font-family: Arial, sans-serif;" value="Arial, sans-serif">Arial</option> <option style="font-family: 'Times New Roman', serif;" value="'Times New Roman', serif">Times New Roman</option> <option style="font-family: 'Courier New', monospace;" value="'Courier New', monospace">Courier New</option> <option style="font-family: Verdana, sans-serif;" value="Verdana, sans-serif">Verdana</option> <option style="font-family: Georgia, serif;" value="Georgia, serif">Georgia</option> <option style="font-family: 'Segoe UI', sans-serif;" value="'Segoe UI', sans-serif">Segoe UI</option> </select> <select class="font-size-select" id="font-size-select" title="Tamaño de Fuente"> <option value="10pt">10</option><option value="11pt">11</option><option value="12pt" selected>12</option><option value="14pt">14</option><option value="16pt">16</option><option value="18pt">18</option><option value="24pt">24</option><option value="36pt">36</option> </select> <button class="icon-button" id="clear-formatting-button" data-action="clear-formatting" title="Borrar Formato (Ctrl+\)"><i class="fas fa-eraser"></i></button> </div>
                <div class="ribbon-separator"></div>
                <div class="ribbon-group formatting-controls"> <button class="icon-button" id="bold-button" data-format="bold" title="Negrita (Ctrl+B)"><i class="fas fa-bold"></i></button> <button class="icon-button" id="italic-button" data-format="italic" title="Cursiva (Ctrl+I)"><i class="fas fa-italic"></i></button> <button class="icon-button" id="underline-button" data-format="underline" title="Subrayado (Ctrl+U)"><i class="fas fa-underline"></i></button> </div>
                <div class="ribbon-separator"></div>
                <div class="ribbon-group indent-controls"> <button class="icon-button" id="outdent-button" data-action="outdent" title="Disminuir Sangría (Shift+Tab)"><i class="fas fa-outdent"></i></button> <button class="icon-button" id="indent-button" data-action="indent" title="Aumentar Sangría (Tab)"><i class="fas fa-indent"></i></button> </div>
                <div class="ribbon-separator"></div>
                <div class="ribbon-group paragraph-controls"> <button class="icon-button" id="align-left-button" data-action="align_left" title="Alinear Izquierda"><i class="fas fa-align-left"></i></button> <button class="icon-button" id="align-center-button" data-action="align_center" title="Centrar"><i class="fas fa-align-center"></i></button> <button class="icon-button" id="align-right-button" data-action="align_right" title="Alinear Derecha"><i class="fas fa-align-right"></i></button> <button class="icon-button" id="align-justify-button" data-action="align_justify" title="Justificar"><i class="fas fa-align-justify"></i></button> </div>
            </div>
            <div class="ribbon-right-menu"> <button class="action-button" id="save-button" data-action="save"><i class="fas fa-save"></i> Guardar</button> </div>
        </div>

        <!-- Main Content Area -->
        <main class="main-content" id="main-content">
             <div class="page-container" id="page-container-1">
                <textarea class="document-area" id="document-area-1" spellcheck="false">Esta es la página 1. Escribe aquí hasta que sientas que estás cerca del final.

Cuando presiones Enter y el contenido (incluyendo la nueva línea) exceda la altura visible del área de texto, se creará una nueva página debajo, con una pequeña animación, y el cursor saltará allí.

Puedes probar copiando y pegando un bloque grande de texto. Luego presiona Enter al final.</textarea>
             </div>
             <!-- New pages added dynamically here -->
        </main>

        <!-- Status Bar HTML -->
         <footer class="status-bar">
            <div class="status-left">
                <span id="page-count">Página 1 de 1</span>
                <span class="ribbon-separator" style="height: 16px; margin: 0 5px;"></span>
                <span id="word-count">Calculando...</span>
                <span id="status-message-area"></span>
            </div>
            <div class="status-right"> <button class="icon-button" id="zoom-out-button" title="Alejar"><i class="fas fa-minus"></i></button> <div class="zoom-slider"> <input type="range" min="50" max="200" value="100" step="10" class="slider" id="zoom-slider-input"> </div> <button class="icon-button" id="zoom-in-button" title="Acercar"><i class="fas fa-plus"></i></button> <span class="zoom-percentage" id="zoom-percentage-display">100%</span> </div>
        </footer>
    </div>

    <script>
        "use strict";

        document.addEventListener('DOMContentLoaded', () => {

            // --- DOM Element References ---
            const mainContent = document.getElementById('main-content');
            const statusMessageArea = document.getElementById('status-message-area');
            const wordCountDisplay = document.getElementById('word-count');
            const pageCountDisplay = document.getElementById('page-count');
            const fontFamilySelect = document.getElementById('font-family-select');
            const fontSizeSelect = document.getElementById('font-size-select');
            const zoomSliderInput = document.getElementById('zoom-slider-input');
            const zoomPercentageDisplay = document.getElementById('zoom-percentage-display');
            const zoomInButton = document.getElementById('zoom-in-button');
            const zoomOutButton = document.getElementById('zoom-out-button');
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            const clearFormattingButton = document.getElementById('clear-formatting-button');
            const boldButton = document.getElementById('bold-button');
            const italicButton = document.getElementById('italic-button');
            const underlineButton = document.getElementById('underline-button');
            const indentButton = document.getElementById('indent-button');
            const outdentButton = document.getElementById('outdent-button');
            const alignLeftButton = document.getElementById('align-left-button');
            const alignCenterButton = document.getElementById('align-center-button');
            const alignRightButton = document.getElementById('align-right-button');
            const alignJustifyButton = document.getElementById('align-justify-button');
            const saveButton = document.getElementById('save-button');

            // --- State Variables ---
            let currentActiveTextarea = document.getElementById('document-area-1');
            let pageCounter = 1;

            let currentStatusTimeout = null;
            const MAX_HISTORY_SIZE = 50;
            let history = [];
            let historyIndex = -1;
            let isPerformingUndoRedo = false;
            let inputDebounceTimeout = null;
            const INPUT_DEBOUNCE_MS = 350;
            let activeCursorStyles = { bold: false, italic: false, underline: false };
            let preparingFormat = false;

            // --- Constants ---
            const DEFAULT_FONT_FAMILY = 'Arial, sans-serif';
            const DEFAULT_FONT_SIZE = '12pt';
            const DEFAULT_ALIGNMENT = 'left';
            const INDENT_CHAR = '\t';
            const MARKERS = { bold: { start: '**', end: '**', button: boldButton, regex: /\*\*(.*?)\*\*/sg }, italic: { start: '*', end: '*', button: italicButton, regex: /\*(.*?)\*/sg }, underline: { start: '__', end: '__', button: underlineButton, regex: /__(.*?)__/sg } };
            const CLEAR_FORMAT_REGEX = { bold: { pair: new RegExp('\\*\\*(.*?)\\*\\*', 'sg') }, italic: { pair: new RegExp('(?<!\\*)\\*(?!\\s)(.*?)(?<!\\s)\\*(?!\\*)', 'sg') }, underline: { pair: new RegExp('__(.*?)__', 'sg') } };


            // --- Utility Functions ---
            function showStatusMessage(message, isError = false, duration = 3000) { /* Unchanged */ if (currentStatusTimeout) clearTimeout(currentStatusTimeout); statusMessageArea.textContent = message; statusMessageArea.className = `status-message ${isError ? 'error' : 'success'}`; currentStatusTimeout = setTimeout(() => { statusMessageArea.textContent = ''; statusMessageArea.className = ''; currentStatusTimeout = null; }, duration); }
            function updatePageCount() { /* Unchanged */ const pages = mainContent.querySelectorAll('.page-container'); const totalPages = pages.length; let currentPageIndex = 0; if (currentActiveTextarea) { const currentContainer = currentActiveTextarea.closest('.page-container'); if (currentContainer) { currentPageIndex = Array.from(pages).indexOf(currentContainer); } } pageCountDisplay.textContent = `Página ${currentPageIndex + 1} de ${totalPages}`; }
            function updateWordCount() { /* Unchanged */ let totalWords = 0; const textAreas = mainContent.querySelectorAll('.document-area'); textAreas.forEach(area => { const text = area.value.trim(); const words = text.length === 0 ? [] : text.split(/\s+/).filter(Boolean); totalWords += words.length; }); wordCountDisplay.textContent = `${totalWords} ${totalWords === 1 ? 'palabra' : 'palabras'}`; }
            function getCurrentStyles(textarea = currentActiveTextarea) { /* Unchanged */ if (!textarea) return {}; return { fontFamily: textarea.style.fontFamily || DEFAULT_FONT_FAMILY, fontSize: textarea.style.fontSize || DEFAULT_FONT_SIZE, textAlign: textarea.style.textAlign || DEFAULT_ALIGNMENT, }; }
            function applyStylesFromState(styles, textarea = currentActiveTextarea) { /* Unchanged */ if (!textarea) return; textarea.style.fontFamily = styles.fontFamily; textarea.style.fontSize = styles.fontSize; textarea.style.textAlign = styles.textAlign; if (textarea === currentActiveTextarea) { fontFamilySelect.value = styles.fontFamily; fontSizeSelect.value = styles.fontSize; updateAlignmentButtons(styles.textAlign); } }

            // --- History Management (Simplified) ---
            function saveState(forceSave = false) { /* Unchanged */ if (isPerformingUndoRedo || !currentActiveTextarea) return; const currentState = { activeTextareaId: currentActiveTextarea.id, text: currentActiveTextarea.value, selectionStart: currentActiveTextarea.selectionStart, selectionEnd: currentActiveTextarea.selectionEnd, styles: getCurrentStyles(currentActiveTextarea), activeCursorStyles: { ...activeCursorStyles }, preparingFormat: preparingFormat }; if (!forceSave && historyIndex >= 0) { const lastState = history[historyIndex]; if (lastState.activeTextareaId === currentState.activeTextareaId && lastState.text === currentState.text && lastState.selectionStart === currentState.selectionStart && lastState.selectionEnd === currentState.selectionEnd && JSON.stringify(lastState.styles) === JSON.stringify(currentState.styles) && JSON.stringify(lastState.activeCursorStyles) === JSON.stringify(currentState.activeCursorStyles) && lastState.preparingFormat === currentState.preparingFormat) { return; } } if (historyIndex < history.length - 1) { history = history.slice(0, historyIndex + 1); } history.push(currentState); historyIndex++; if (history.length > MAX_HISTORY_SIZE) { history.shift(); historyIndex--; } updateUndoRedoButtons(); }
            function updateUndoRedoButtons() { /* Unchanged */ undoButton.disabled = historyIndex <= 0; redoButton.disabled = historyIndex >= history.length - 1; }
            function restoreSelection(textarea, start, end) { /* Unchanged */ requestAnimationFrame(() => { try { if (!textarea) textarea = currentActiveTextarea; if (!textarea || document.activeElement !== textarea) { textarea?.focus(); } if(textarea) { const maxPos = textarea.value.length; const safeStart = Math.max(0, Math.min(start, maxPos)); const safeEnd = Math.max(safeStart, Math.min(end, maxPos)); textarea.setSelectionRange(safeStart, safeEnd); } updateFormattingButtonsState(textarea); } catch (e) { console.error("Error restoring selection:", e); } }); }
            function restoreState(index) { /* Unchanged */ if (index < 0 || index >= history.length) return; isPerformingUndoRedo = true; const stateToRestore = history[index]; const targetTextarea = document.getElementById(stateToRestore.activeTextareaId); if (!targetTextarea) { console.warn("Cannot restore state: Textarea", stateToRestore.activeTextareaId, "not found."); isPerformingUndoRedo = false; return; } currentActiveTextarea = targetTextarea; applyStylesFromState(stateToRestore.styles, targetTextarea); activeCursorStyles = { ...stateToRestore.activeCursorStyles }; preparingFormat = stateToRestore.preparingFormat; targetTextarea.value = stateToRestore.text; updateWordCount(); updatePageCount(); historyIndex = index; updateUndoRedoButtons(); restoreSelection(targetTextarea, stateToRestore.selectionStart, stateToRestore.selectionEnd); targetTextarea.closest('.page-container')?.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); setTimeout(() => { isPerformingUndoRedo = false; updateFormattingButtonsState(currentActiveTextarea); }, 50); }
            function updateAlignmentButtons(alignment) { /* Unchanged */ alignLeftButton.classList.toggle('selected', alignment === 'left'); alignCenterButton.classList.toggle('selected', alignment === 'center'); alignRightButton.classList.toggle('selected', alignment === 'right'); alignJustifyButton.classList.toggle('selected', alignment === 'justify'); }

            // --- Core Formatting Logic (Accepts textarea) ---
            function isCursorInsideMarker(text, cursorPos, marker) { /* Unchanged logic */ const { start: startMarker, end: endMarker } = marker; let openIdx = text.lastIndexOf(startMarker, cursorPos - 1); while (openIdx !== -1) { let closeIdx = text.indexOf(endMarker, openIdx + startMarker.length); if (closeIdx !== -1) { if (cursorPos > openIdx + startMarker.length && cursorPos <= closeIdx) { return true; } } openIdx = text.lastIndexOf(startMarker, openIdx - 1); } return false; }
            function updateFormattingButtonsState(textarea = currentActiveTextarea) { /* Logic Unchanged */ if (isPerformingUndoRedo || !textarea) return; const start = textarea.selectionStart; const end = textarea.selectionEnd; const content = textarea.value; const hasSelection = start !== end; let derivedStyles = { bold: false, italic: false, underline: false }; if (hasSelection) { const selectedText = content.substring(start, end); for (const format in MARKERS) { const marker = MARKERS[format]; const isFullyWrapped = selectedText.startsWith(marker.start) && selectedText.endsWith(marker.end) && selectedText.length >= marker.start.length + marker.end.length; derivedStyles[format] = isFullyWrapped; marker.button.classList.toggle('selected', derivedStyles[format]); } preparingFormat = false; } else { for (const format in MARKERS) { const marker = MARKERS[format]; const isInside = isCursorInsideMarker(content, start, marker); const isActiveIntent = activeCursorStyles[format]; derivedStyles[format] = isInside || isActiveIntent; marker.button.classList.toggle('selected', derivedStyles[format]); if(isInside) { activeCursorStyles[format] = true; } else { activeCursorStyles[format] = isActiveIntent; } } } }
            function applyFormatToSelection(format, textarea = currentActiveTextarea) { /* Logic Unchanged */ if(!textarea) return; const marker = MARKERS[format]; if (!marker) return; let start = textarea.selectionStart; let end = textarea.selectionEnd; if (start === end) return; let content = textarea.value; let selectedText = content.substring(start, end); let textBefore = content.substring(0, start); let textAfter = content.substring(end); const isAlreadyFullyFormatted = selectedText.startsWith(marker.start) && selectedText.endsWith(marker.end) && selectedText.length >= marker.start.length + marker.end.length; let newSelectedText; let finalStart = start; let finalEnd; if (isAlreadyFullyFormatted) { newSelectedText = selectedText.slice(marker.start.length, selectedText.length - marker.end.length); finalEnd = start + newSelectedText.length; activeCursorStyles[format] = false; } else { let textToWrap = selectedText; let previousText; do { previousText = textToWrap; textToWrap = textToWrap.replace(marker.regex, '$1'); } while (previousText !== textToWrap); if (textToWrap.startsWith(marker.start)) textToWrap = textToWrap.slice(marker.start.length); if (textToWrap.endsWith(marker.end)) textToWrap = textToWrap.slice(0, -marker.end.length); newSelectedText = marker.start + textToWrap + marker.end; finalEnd = start + newSelectedText.length; activeCursorStyles[format] = true; } textarea.value = textBefore + newSelectedText + textAfter; clearTimeout(inputDebounceTimeout); updateWordCount(); saveState(true); restoreSelection(textarea, finalStart, finalEnd); }
            function handleFormatButtonClick(format) { /* Logic Unchanged */ if (!currentActiveTextarea) return; const textarea = currentActiveTextarea; const marker = MARKERS[format]; if (!marker) return; const start = textarea.selectionStart; const end = textarea.selectionEnd; const content = textarea.value; textarea.focus(); if (start !== end) { applyFormatToSelection(format, textarea); } else { const currentState = activeCursorStyles[format]; const isInside = isCursorInsideMarker(content, start, marker); if (isInside && currentState) { activeCursorStyles[format] = false; preparingFormat = false; } else { activeCursorStyles[format] = !currentState; preparingFormat = activeCursorStyles[format]; } marker.button.classList.toggle('selected', activeCursorStyles[format]); saveState(true); restoreSelection(textarea, start, end); } }
            function insertCharWithMarkers(char, textarea = currentActiveTextarea) { /* Logic Unchanged */ if(!textarea) return; const start = textarea.selectionStart; const end = textarea.selectionEnd; let content = textarea.value; let prefix = ''; let suffix = ''; if (activeCursorStyles.bold) { prefix += MARKERS.bold.start; suffix = MARKERS.bold.end + suffix; } if (activeCursorStyles.italic) { prefix += MARKERS.italic.start; suffix = MARKERS.italic.end + suffix; } if (activeCursorStyles.underline) { prefix += MARKERS.underline.start; suffix = MARKERS.underline.end + suffix; } const textToInsert = prefix + char + suffix; const finalCursorPos = start + prefix.length + char.length; textarea.value = content.substring(0, start) + textToInsert + content.substring(end); preparingFormat = false; clearTimeout(inputDebounceTimeout); updateWordCount(); saveState(true); restoreSelection(textarea, finalCursorPos, finalCursorPos); }
            function insertCharWithoutMarkers(char, textarea = currentActiveTextarea) { /* Logic Unchanged */ if(!textarea) return; const start = textarea.selectionStart; const end = textarea.selectionEnd; let content = textarea.value; const textToInsert = char; const finalCursorPos = start + char.length; textarea.value = content.substring(0, start) + textToInsert + content.substring(end); preparingFormat = false; clearTimeout(inputDebounceTimeout); updateWordCount(); saveState(true); restoreSelection(textarea, finalCursorPos, finalCursorPos); }
            function modifyIndent(increase = true, textarea = currentActiveTextarea) { /* Logic Unchanged */ if(!textarea) return; const start = textarea.selectionStart; const end = textarea.selectionEnd; const originalValue = textarea.value; let lineStartIndex = start; while (lineStartIndex > 0 && originalValue[lineStartIndex - 1] !== '\n') { lineStartIndex--; } let effectiveEnd = (end > start && originalValue[end - 1] === '\n') ? end - 1 : end; let lineEndIndex = effectiveEnd; while (lineEndIndex < originalValue.length && originalValue[lineEndIndex] !== '\n') { lineEndIndex++; } const textBeforeLines = originalValue.substring(0, lineStartIndex); const selectedLinesText = originalValue.substring(lineStartIndex, lineEndIndex); const textAfterLines = originalValue.substring(lineEndIndex); const lines = selectedLinesText.split('\n'); let changeInLength = 0; let firstLineChange = 0; const modifiedLines = lines.map((line, index) => { let lineChange = 0; if (increase) { line = INDENT_CHAR + line; lineChange = INDENT_CHAR.length; } else { if (line.startsWith(INDENT_CHAR)) { line = line.substring(INDENT_CHAR.length); lineChange = -INDENT_CHAR.length; } else if (line.startsWith(" ")) { let i = 0; while(line[i] === ' ' && i < 4) i++; if(i > 0) { line = line.substring(i); lineChange = -i; } } } if (index === 0) { firstLineChange = lineChange; } changeInLength += lineChange; return line; }); const newValue = textBeforeLines + modifiedLines.join('\n') + textAfterLines; textarea.value = newValue; const selectionIncludesFirstCharOfLine = (start <= lineStartIndex); let newStart = start; if (selectionIncludesFirstCharOfLine) { newStart += firstLineChange; } else { if (firstLineChange < 0) { newStart = Math.max(lineStartIndex, start + firstLineChange); } } newStart = Math.max(lineStartIndex, newStart); const newEnd = Math.max(newStart, end + changeInLength); clearTimeout(inputDebounceTimeout); updateWordCount(); saveState(true); restoreSelection(textarea, newStart, newEnd); }

            // --- Function to Add Listeners ---
             function addListenersToTextarea(textareaElement) { /* Unchanged */ textareaElement.addEventListener('input', (e) => { const ct = e.target; updateWordCount(); clearTimeout(inputDebounceTimeout); inputDebounceTimeout = setTimeout(() => { if(currentActiveTextarea === ct) { saveState(); } }, INPUT_DEBOUNCE_MS); }); textareaElement.addEventListener('keydown', handleTextareaKeydown); }

            // --- MODIFIED Function to Create a New Page ---
            function createNewPage(afterPageContainer) {
                pageCounter++; // Use existing counter logic
                const newPageId = pageCounter; // Use the incremented counter for ID
                const newPage = document.createElement('div');
                newPage.className = 'page-container new-page-entering'; // Add animation class
                newPage.id = `page-container-${newPageId}`;

                const newTextarea = document.createElement('textarea');
                newTextarea.className = 'document-area';
                newTextarea.id = `document-area-${newPageId}`;
                newTextarea.spellcheck = false;
                newTextarea.value = ""; // Start blank

                // Inherit non-marker styles from the previous active one
                applyStylesFromState(getCurrentStyles(currentActiveTextarea), newTextarea);

                newPage.appendChild(newTextarea);
                afterPageContainer.after(newPage); // Insert after the specified page
                addListenersToTextarea(newTextarea); // Add event listeners

                // Apply current zoom
                const currentZoom = zoomSliderInput.value / 100;
                newPage.style.transform = `scale(${currentZoom})`; // Set initial scale for animation

                // Force reflow to ensure transition is applied correctly
                void newPage.offsetWidth;

                // Remove animation class after a short delay to trigger transition
                requestAnimationFrame(() => {
                    newPage.classList.remove('new-page-entering');
                    // Reset transform *after* removing the class if needed, but scale is okay
                    newPage.style.transform = `translateY(0) scale(${currentZoom})`; // Ensure final position
                    newPage.style.opacity = 1;
                });


                updatePageCount(); // Update the page counter display

                return newTextarea; // Return the new textarea element
            }

            // --- MODIFIED Central Keydown Handler Function ---
             function handleTextareaKeydown(e) {
                 const textarea = e.target;
                 const isCurrentActive = textarea === currentActiveTextarea;

                  if (!isCurrentActive) { // Update context if needed
                     currentActiveTextarea = textarea;
                     applyStylesFromState(getCurrentStyles(textarea), textarea);
                     updateFormattingButtonsState(textarea);
                     updatePageCount();
                 }

                 const start = textarea.selectionStart;
                 const end = textarea.selectionEnd;
                 const content = textarea.value;
                 let handled = false;

                 // 1. Enter Key: Check for new page creation
                 if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
                    const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight) || 18;
                    const buffer = lineHeight * 0.5; // Smaller buffer
                    // Check if the scrollHeight is already exceeding or very close to clientHeight
                    if (textarea.scrollHeight > textarea.clientHeight - buffer) {
                        // AND check if the cursor is within the last ~1.5 lines
                        const cursorVerticalPosition = (content.substring(0, start).split('\n').length) * lineHeight;
                         if (cursorVerticalPosition > textarea.clientHeight - lineHeight * 1.5) {

                             e.preventDefault(); // Prevent default Enter action
                             handled = true;

                             const currentPageElem = textarea.closest('.page-container');
                             if (currentPageElem) {
                                 saveState(true); // Save state of current page *before* creating new one

                                 const newTextArea = createNewPage(currentPageElem);

                                 // Insert the newline at the beginning of the new page
                                 newTextArea.value = '\n';
                                 const newCursorPos = 1; // After the newline

                                 newTextArea.focus(); // Triggers focusin handler
                                 restoreSelection(newTextArea, newCursorPos, newCursorPos); // Set cursor

                                 // Scroll handled by focusin and subsequent checks maybe?
                                 // Or force scroll here:
                                  requestAnimationFrame(() => {
                                     newTextArea.closest('.page-container')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                  });

                             } else {
                                 console.error("Could not find current page container");
                                 handled = false; // Allow default Enter if container missing
                             }
                         } else {
                              // Cursor not near the end, allow default enter
                              preparingFormat = false;
                         }
                    } else {
                         // Not overflowing, allow default Enter
                         preparingFormat = false;
                    }
                 } // --- End Enter Key Logic ---

                 // 2. Tab Indentation
                 if (!handled && e.key === 'Tab' && !e.ctrlKey && !e.metaKey && !e.altKey) { e.preventDefault(); modifyIndent(!e.shiftKey, textarea); handled = true; }

                 // 3. Ctrl/Cmd Shortcuts
                 if (!handled && (e.ctrlKey || e.metaKey)) { /* Unchanged Shortcut Logic */ switch (e.key.toLowerCase()) { case 'z': if (!undoButton.disabled) { undoButton.click(); handled = true; } break; case 'y': if (!redoButton.disabled) { redoButton.click(); handled = true; } break; case 'b': boldButton.click(); handled = true; break; case 'i': italicButton.click(); handled = true; break; case 'u': underlineButton.click(); handled = true; break; case 's': saveButton.click(); handled = true; break; case '\\': clearFormattingButton.click(); handled = true; break; } if (handled) e.preventDefault(); }

                 // 4. Character Input Handling
                 if (!handled && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.length === 1 && start === end) { /* Unchanged Logic */ const hasAnyActiveStyle = activeCursorStyles.bold || activeCursorStyles.italic || activeCursorStyles.underline; if (hasAnyActiveStyle || preparingFormat) { let alreadyInsideAllActive = true; if (activeCursorStyles.bold && !isCursorInsideMarker(content, start, MARKERS.bold)) alreadyInsideAllActive = false; if (activeCursorStyles.italic && !isCursorInsideMarker(content, start, MARKERS.italic)) alreadyInsideAllActive = false; if (activeCursorStyles.underline && !isCursorInsideMarker(content, start, MARKERS.underline)) alreadyInsideAllActive = false; if (preparingFormat || (hasAnyActiveStyle && !alreadyInsideAllActive) ) { e.preventDefault(); insertCharWithMarkers(e.key, textarea); handled = true; } else if (hasAnyActiveStyle && alreadyInsideAllActive) { e.preventDefault(); insertCharWithoutMarkers(e.key, textarea); handled = true; } } if (!handled) { preparingFormat = false; } }

                 // 5. Navigation Keys
                 if (!handled && ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(e.key)) { preparingFormat = false; }

                 // 6. Deletion Keys
                 if (!handled && (e.key === 'Backspace' || e.key === 'Delete')) { preparingFormat = false; }

             } // --- End handleTextareaKeydown ---


            // --- Initial Setup ---
            applyStylesFromState(getCurrentStyles(currentActiveTextarea), currentActiveTextarea);
            updateWordCount();
            updatePageCount(); // Initial page count
            saveState(true);
            updateFormattingButtonsState(currentActiveTextarea);
            addListenersToTextarea(currentActiveTextarea);

            // --- Event Delegation for Focus ---
            mainContent.addEventListener('focusin', (e) => { /* Unchanged */ if (e.target && e.target.classList.contains('document-area')) { const focusedTextarea = e.target; if (focusedTextarea !== currentActiveTextarea) { currentActiveTextarea = focusedTextarea; applyStylesFromState(getCurrentStyles(focusedTextarea), focusedTextarea); updateFormattingButtonsState(focusedTextarea); updatePageCount(); preparingFormat = false; } } });

             // Selection Change Listener
             let selectionChangeTimeout = null;
             document.addEventListener('selectionchange', () => { /* Unchanged */ if (isPerformingUndoRedo || !currentActiveTextarea || document.activeElement !== currentActiveTextarea) return; clearTimeout(selectionChangeTimeout); selectionChangeTimeout = setTimeout(() => { updateFormattingButtonsState(currentActiveTextarea); }, 50); });

            // --- Global Event Listeners --- (Unchanged - Operate on currentActiveTextarea)
            fontFamilySelect.addEventListener('change', (e) => { if(!currentActiveTextarea) return; const start = currentActiveTextarea.selectionStart, end = currentActiveTextarea.selectionEnd; currentActiveTextarea.style.fontFamily = e.target.value; saveState(true); restoreSelection(currentActiveTextarea, start, end); });
            fontSizeSelect.addEventListener('change', (e) => { if(!currentActiveTextarea) return; const start = currentActiveTextarea.selectionStart, end = currentActiveTextarea.selectionEnd; currentActiveTextarea.style.fontSize = e.target.value; saveState(true); restoreSelection(currentActiveTextarea, start, end); });
            clearFormattingButton.addEventListener('click', () => { if (!currentActiveTextarea) return; const textarea = currentActiveTextarea; const start = textarea.selectionStart; const end = textarea.selectionEnd; const hadSelection = start !== end; const currentAlignment = textarea.style.textAlign || DEFAULT_ALIGNMENT; applyStylesFromState({ fontFamily: DEFAULT_FONT_FAMILY, fontSize: DEFAULT_FONT_SIZE, textAlign: currentAlignment }, textarea); activeCursorStyles = { bold: false, italic: false, underline: false }; preparingFormat = false; let selectionLengthAfterClear = end - start; if (hadSelection) { let content = textarea.value; let textBefore = content.substring(0, start); let selectedText = content.substring(start, end); let textAfter = content.substring(end); const formatsToClear = ['bold', 'italic', 'underline']; formatsToClear.forEach(fmt => { const regexPair = CLEAR_FORMAT_REGEX[fmt]?.pair; if (regexPair) { let previousText; do { previousText = selectedText; selectedText = selectedText.replace(regexPair, '$1'); } while (previousText !== selectedText && regexPair.test(selectedText)); } }); textarea.value = textBefore + selectedText + textAfter; selectionLengthAfterClear = selectedText.length; showStatusMessage('Formato de selección borrado'); } else { updateFormattingButtonsState(textarea); showStatusMessage('Formato del cursor reiniciado', false, 1500); } updateWordCount(); saveState(true); restoreSelection(textarea, start, start + selectionLengthAfterClear); });
            [boldButton, italicButton, underlineButton].forEach(button => { button.addEventListener('click', () => handleFormatButtonClick(button.dataset.format)); });
            indentButton.addEventListener('click', () => modifyIndent(true));
            outdentButton.addEventListener('click', () => modifyIndent(false));
            [alignLeftButton, alignCenterButton, alignRightButton, alignJustifyButton].forEach(button => { button.addEventListener('click', () => { if (!currentActiveTextarea) return; const start = currentActiveTextarea.selectionStart, end = currentActiveTextarea.selectionEnd; const action = button.dataset.action; let alignment = action.split('_')[1]; currentActiveTextarea.style.textAlign = alignment; updateAlignmentButtons(alignment); saveState(true); restoreSelection(currentActiveTextarea, start, end); }); });
            undoButton.addEventListener('click', () => restoreState(historyIndex - 1));
            redoButton.addEventListener('click', () => restoreState(historyIndex + 1));
            document.addEventListener('click', (e) => { if (!mainContent.contains(e.target) && !e.target.closest('.ribbon-bar')) { if (preparingFormat) { preparingFormat = false; } } });

            // Zoom Event Listeners
            function applyZoom() { const zoomValue = zoomSliderInput.value; zoomPercentageDisplay.textContent = `${zoomValue}%`; const scaleValue = zoomValue / 100; const pages = mainContent.querySelectorAll('.page-container'); pages.forEach(page => { page.style.transform = `scale(${scaleValue})`; /* Apply only scale now */ }); }
            zoomSliderInput.addEventListener('input', applyZoom);
            zoomInButton.addEventListener('click', () => { zoomSliderInput.stepUp(); applyZoom(); });
            zoomOutButton.addEventListener('click', () => { zoomSliderInput.stepDown(); applyZoom(); });

            // Save Button listener
            saveButton.addEventListener('click', () => { console.log('--- Simulando Guardado ---'); const allContent = Array.from(mainContent.querySelectorAll('.document-area')).map(ta => ta.value).join('\n<--PAGE BREAK-->\n'); console.log("Contenido Total:\n", allContent); showStatusMessage('Documento guardado (simulado)', false); saveState(true); });

            console.log('Editor Pro v11 Inicializado (Páginas Discretas Animadas)');

        }); // End DOMContentLoaded
    </script>

</body>
</html>
